In this exercise, we learn how to benchmark an application, i.e. see what memory it used and how long it took to run.

Log into Myriad and then issue the following commands. This will build a program
(`calculate_pi`) which, when run, gives an estimate of the value of pi.

```
{{ site.workshop_host_prompt }} mkdir ~/Scratch/workspace
{{ site.workshop_host_prompt }} cd ~/Scratch/workspace
{{ site.workshop_host_prompt }} cp -r /shared/ucl/apps/examples/calculate_pi_dir .
{{ site.workshop_host_prompt }} cd calculate_pi_dir
{{ site.workshop_host_prompt }} make
```
{: .bash}

```
icc -c calculate_pi.c -o calculate_pi.o
icc -c pi_mytime.c -o pi_mytime.o
icc -o calculate_pi calculate_pi.o pi_mytime.o
```
{: .output}

If you run `ls` you should notice the new executable has been built.
You tell the program how many iterations you wish it to perform.
The more iterations, the more accurate the value of pi produced.
But the longer it will take. We must *not* run this program with
a high number of iterations on this login node.

Check the program works when used with a SMALL number of iterations:

```
{{{ site.host_prompt }} ./calculate_pi 10
```
{: .bash}

```
Calculating PI using calculate_pi using 10 steps...
The value of PI is 3.33118
The time to calculate PI was 9.53674e-07 seconds
```
{: .output}

We can gather some information about the resources we use. To demonstrate, we
re-run the program (with a SMALL number of iterations) and time it:

```
{{ site.host_prompt }} /usr/bin/time --verbose ./calculate_pi 100
```
{: .bash}

```
Calculating PI using calculate_pi using 100 steps...
The value of PI is 3.1615
The time to calculate PI was 0 seconds
	Command being timed: "./calculate_pi 100"
	User time (seconds): 0.00
	System time (seconds): 0.00
	Percent of CPU this job got: 9%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.02
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 664
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 214
	Voluntary context switches: 3
	Involuntary context switches: 1
	Swaps: 0
	File system inputs: 0
	File system outputs: 0
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 0
```
{: .output}

In order to get a more accurate value of pi, we need to run the program
with a large number of iterations. (Not specifying a number means it will use
1000000000). We do not do this on the login node, but must submit a job script.
In your `~/Scratch/workspace/calculate_pi` directory, create a file `calc_pi.sh`
and enter the following, ensuring you replace <your_UCL_id> with your UCL ID
in the command line:

```
#!/bin/bash -l
# Batch script to run a serial job under SGE.

# Request ten minutes of wallclock time (format hours:minutes:seconds).
#$ -l h_rt=0:10:0

# Request 1 gigabyte of RAM (must be an integer followed by M, G, or T)
#$ -l mem=1G

# Request 15 gigabyte of TMPDIR space (default is 10 GB)
#$ -l tmpfs=15G

# Set the name of the job.
#$ -N Serial_Job

# Set the working directory to somewhere in your scratch space.
#  This is a necessary step as compute nodes cannot write to $HOME.
# Replace "<your_UCL_id>" with your UCL user ID.
#$ -wd /home/<your_UCL_id>/Scratch/workspace

# Your work should be done in $TMPDIR
cd $TMPDIR

# Run the application and put the output into a file called results.txt
/usr/bin/time --verbose ~/Scratch/workspace/calculate_pi_dir/calculate_pi > results.txt

# Preferably, tar-up (archive) all output files onto the shared scratch area
tar -zcvf $HOME/Scratch/files_from_job_$JOB_ID.tar.gz $TMPDIR

# Make sure you have given enough time for the copy to complete!
```

Submit the job with `{{ site.sched_submit }}`:

```
{{ site.host_prompt }} {{ site.sched_submit }} calc_pi.sh
```
{: .bash}

```
Your job 4053574 ("Serial_Job") has been submitted
```
{: .output}

```
{{ site.host_prompt }} {{ site.sched_status }}
```
{: .bash}

```
job-ID  prior   name       user         state submit/start at     queue                          slots ja-task-ID
-----------------------------------------------------------------------------------------------------------------
4053574 0.00000 Serial_Job user      qw    07/02/2020 15:34:40
```
{: .output}

By periodically checking the queue with `{{ site.sched_status }}`, we can see when our job is running:

```
{{ site.host_prompt }} {{ site.sched_status }}
```
{: .bash}

```
job-ID  prior   name       user         state submit/start at     queue                          slots ja-task-ID
-----------------------------------------------------------------------------------------------------------------
4053574 3.50000 Serial_Job cceagil      r     07/02/2020 15:35:53 Arya@node-f00a-001                 1
```
{: .output}

When the job is running, basic information about it can be obtained with `nodesforjob`:

```
{{ site.host_prompt }} nodesforjob 4053574
```
{: .bash}

```
Nodes for job 4053574:
  Primary:
    node-f00a-001:  21.9 % load, 22.3 % memory used, 1.1% swap used
```
{: .output}



`{{ site.sched_hist }}`` gives more information:

```
{{ site.host_prompt }} {{ site.sched_hist }}
```
{: .bash}

```
        FSTIME        |       FETIME        |   HOSTNAME    |  OWNER  | JOB NUMBER | TASK NUMBER | EXIT STATUS |  JOB NAME   
----------------------+---------------------+---------------+---------+------------+-------------+-------------+-------------
  1970-01-01 01:00:00 | 1970-01-01 01:00:00 | node-i00a-002 | cceagil |    4029963 |           0 |           0 | Serial_Job  
  2020-07-01 16:12:31 | 2020-07-01 16:12:31 | node-b00a-007 | cceagil |    4030977 |           0 |           0 | Serial_Job  
  2020-07-01 16:38:40 | 2020-07-01 16:38:42 | node-i00a-002 | cceagil |    4031101 |           0 |           0 | Serial_Job  
  2020-07-02 15:37:56 | 2020-07-02 15:37:58 | node-f00a-001 | cceagil |    4053574 |           0 |           0 | Serial_Job
```
{: .output}

Once the job has finished, if you now `cd` up one level, you should see files
with names like `Serial_Job.e4053574` and `Serial_Job.o4053574`. These contain
information about your job (e.g. the timing information) whose number was the one
in the file title.

If you go up another couple of levels, to your `Scratch` directory, you should find
a compressed archive file with a name like `files_from_job_4053574.tar.gz`. The number in the file
title should be the same as the `Serial.Job` files we looked at a moment ago.

Extract the contents of the archive:

```
{{ site.host_prompt }} tar zxvf files_from_job_4053574.tar.gz
```
{: .bash}

```
tmpdir/job/4053574.undefined/
tmpdir/job/4053574.undefined/results.txt
tmpdir/job/4053574.undefined/.smpd
```
{: .output}

```
{{ site.host_prompt }} ls
```
{: .bash}

```
files_from_job_4053574.tar.gz  tmpdir  workspace
```
{: .output}

Explore the `tmpdir` directory. You should find a results file a couple of levels in:

```
{{ site.host_prompt }} cat tmpdir/job/4053574.undefined/results.txt
```
{: .bash}

```
Calculating PI using calculate_pi using 1000000000 steps...
The value of PI is 3.14159
The time to calculate PI was 1.36849 seconds
```
{: .output}

